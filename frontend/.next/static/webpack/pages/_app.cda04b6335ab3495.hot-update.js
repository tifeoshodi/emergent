"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./src/lib/api.js":
/*!************************!*\
  !*** ./src/lib/api.js ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// PMFusion Three-Phase Workflow API Client\n// URL validation function\nconst validateApiUrl = (url)=>{\n    if (!url || typeof url !== 'string') {\n        return false;\n    }\n    try {\n        const urlObj = new URL(url);\n        // Check if it's HTTP or HTTPS protocol\n        return urlObj.protocol === 'http:' || urlObj.protocol === 'https:';\n    } catch (error) {\n        return false;\n    }\n};\n// Get and validate API base URL\nconst getValidatedApiUrl = ()=>{\n    const envUrl = process.env.REACT_APP_BACKEND_URL;\n    // Default to the v1 API running locally\n    const defaultUrl = 'http://localhost:8000/api';\n    // First, try the environment variable\n    if (envUrl && validateApiUrl(envUrl)) {\n        if (true) {\n            console.log('Using API URL from environment:', envUrl);\n        }\n        return envUrl;\n    }\n    // If environment URL is invalid, log warning and check default\n    if (envUrl && !validateApiUrl(envUrl)) {\n        if (true) {\n            console.warn('Invalid API URL in environment variable REACT_APP_BACKEND_URL:', envUrl);\n        }\n    }\n    // Validate the default URL\n    if (validateApiUrl(defaultUrl)) {\n        if (true) {\n            console.log('Using default API URL:', defaultUrl);\n        }\n        return defaultUrl;\n    }\n    // If even the default is invalid (should never happen), throw error\n    throw new Error('No valid API URL available. Please check REACT_APP_BACKEND_URL environment variable.');\n};\nconst API_BASE_URL = getValidatedApiUrl();\nconst API_TIMEOUT_MS = 10000; // 10 second timeout\nclass PMFusionAPI {\n    // Helper method to get auth headers\n    async getAuthHeaders() {\n        const userId =  true ? localStorage.getItem('userId') : 0;\n        // Use demo user as fallback if no user is logged in\n        const demoUserId = 'aa83214c-367b-4231-a682-0bcc4417d954';\n        return {\n            'Content-Type': 'application/json',\n            'X-User-ID': userId || demoUserId\n        };\n    }\n    // Generic API request method with timeout\n    async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const headers = await this.getAuthHeaders();\n        const config = {\n            headers,\n            ...options\n        };\n        try {\n            // Create an AbortController to handle timeouts\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), API_TIMEOUT_MS);\n            const response = await fetch(\"\".concat(this.baseURL).concat(endpoint), {\n                ...config,\n                signal: controller.signal\n            });\n            // Clear the timeout since the request completed\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                let errorMessage = \"API Error: \".concat(response.status, \" - \").concat(response.statusText);\n                try {\n                    const errorData = await response.json();\n                    errorMessage += \" - \".concat(errorData.message || errorData.error || JSON.stringify(errorData));\n                } catch (e) {\n                    const errorText = await response.text();\n                    errorMessage += \" - \".concat(errorText);\n                }\n                throw new Error(errorMessage);\n            }\n            return await response.json();\n        } catch (error) {\n            if (error.name === 'AbortError') {\n                throw new Error(\"API request timeout after \".concat(API_TIMEOUT_MS, \"ms\"));\n            }\n            console.error(\"API Error for \".concat(endpoint, \":\"), error);\n            throw error;\n        }\n    }\n    // ============================================================================\n    // PHASE 1: PROJECT CREATION ENDPOINTS\n    // ============================================================================\n    async createProject(projectData) {\n        return this.request('/projects', {\n            method: 'POST',\n            body: JSON.stringify(projectData)\n        });\n    }\n    async getProjects() {\n        return this.request('/projects');\n    }\n    async getProject(projectId) {\n        return this.request(\"/projects/\".concat(projectId));\n    }\n    async updateProject(projectId, projectData) {\n        return this.request(\"/projects/\".concat(projectId), {\n            method: 'PUT',\n            body: JSON.stringify(projectData)\n        });\n    }\n    async generateProjectWBS(projectId) {\n        return this.request(\"/projects/\".concat(projectId, \"/wbs\"), {\n            method: 'POST'\n        });\n    }\n    async getProjectWBS(projectId) {\n        return this.request(\"/projects/\".concat(projectId, \"/wbs\"));\n    }\n    async syncTasksFromWBS(projectId) {\n        return this.request(\"/projects/\".concat(projectId, \"/wbs/sync-tasks\"), {\n            method: 'POST'\n        });\n    }\n    async getTasks() {\n        let projectId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n        const endpoint = projectId ? \"/tasks?project_id=\".concat(projectId) : '/tasks';\n        return this.request(endpoint);\n    }\n    async assignTask(taskId, assignedTo) {\n        return this.request(\"/tasks/\".concat(taskId, \"/assign\"), {\n            method: 'PUT',\n            body: JSON.stringify({\n                assigned_to: assignedTo\n            })\n        });\n    }\n    async getDisciplineUsers(discipline) {\n        return this.request(\"/disciplines/\".concat(discipline, \"/users\"));\n    }\n    // ============================================================================\n    // PHASE 2: TEAMS EXECUTION ENDPOINTS\n    // ============================================================================\n    async getDisciplineKanban(disciplineId, projectId) {\n        return this.request(\"/disciplines/\".concat(disciplineId, \"/kanban?project_id=\").concat(projectId));\n    }\n    async updateTask(taskId, taskData) {\n        return this.request(\"/tasks/\".concat(taskId), {\n            method: 'PUT',\n            body: JSON.stringify(taskData)\n        });\n    }\n    async assignTask(taskId, assigneeId) {\n        return this.updateTask(taskId, {\n            assignee_id: assigneeId\n        });\n    }\n    async updateTaskStatus(taskId, status) {\n        return this.updateTask(taskId, {\n            status\n        });\n    }\n    // ========================================================================\n    // PHASE 3: DOCUMENT CONTROL ENDPOINTS\n    // ========================================================================\n    async getDocuments() {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const query = new URLSearchParams();\n        if (params.status) query.append('status', params.status);\n        if (params.review_step) query.append('review_step', params.review_step);\n        if (params.project_id) query.append('project_id', params.project_id);\n        const qs = query.toString();\n        const endpoint = qs ? \"/documents?\".concat(qs) : '/documents';\n        return this.request(endpoint);\n    }\n    async getDccDocuments() {\n        return this.request('/documents/dcc');\n    }\n    async finalizeDocument(documentId) {\n        return this.request(\"/documents/\".concat(documentId, \"/dcc_finalize\"), {\n            method: 'POST'\n        });\n    }\n    async updateDocumentStatus(documentId, statusData) {\n        return this.request(\"/documents/\".concat(documentId, \"/status\"), {\n            method: 'PUT',\n            body: JSON.stringify(statusData)\n        });\n    }\n    async getDocumentAnalytics(projectId) {\n        const endpoint = projectId ? \"/documents/analytics/summary?project_id=\".concat(projectId) : '/documents/analytics/summary';\n        return this.request(endpoint);\n    }\n    // ============================================================================\n    // GENERAL ENDPOINTS\n    // ============================================================================\n    async getDisciplines() {\n        return this.request('/disciplines');\n    }\n    async createDiscipline(disciplineData) {\n        return this.request('/disciplines', {\n            method: 'POST',\n            body: JSON.stringify(disciplineData)\n        });\n    }\n    async addDisciplineMember(name, userId) {\n        return this.request(\"/disciplines/\".concat(name, \"/members/\").concat(userId), {\n            method: 'POST'\n        });\n    }\n    async removeDisciplineMember(name, userId) {\n        return this.request(\"/disciplines/\".concat(name, \"/members/\").concat(userId), {\n            method: 'DELETE'\n        });\n    }\n    async healthCheck() {\n        return this.request('/health');\n    }\n    constructor(){\n        this.baseURL = API_BASE_URL;\n    }\n}\n// Create singleton instance\nconst pmfusionAPI = new PMFusionAPI();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pmfusionAPI);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dEI7SUFFQSxNQUFNb0UsaUJBQWlCQyxjQUFjLEVBQUU7UUFDckMsT0FBTyxJQUFJLENBQUNyRSxPQUFPLENBQUMsZ0JBQWdCO1lBQ2xDNkIsUUFBUTtZQUNSQyxNQUFNUixLQUFLQyxTQUFTLENBQUM4QztRQUN2QjtJQUNGO0lBRUEsTUFBTUMsb0JBQW9CNUMsSUFBSSxFQUFFOUIsTUFBTSxFQUFFO1FBQ3RDLE9BQU8sSUFBSSxDQUFDSSxPQUFPLENBQUMsZ0JBQWdDSixPQUFoQjhCLE1BQUssYUFBa0IsT0FBUDlCLFNBQVU7WUFDNURpQyxRQUFRO1FBQ1Y7SUFDRjtJQUVBLE1BQU0wQyx1QkFBdUI3QyxJQUFJLEVBQUU5QixNQUFNLEVBQUU7UUFDekMsT0FBTyxJQUFJLENBQUNJLE9BQU8sQ0FBQyxnQkFBZ0NKLE9BQWhCOEIsTUFBSyxhQUFrQixPQUFQOUIsU0FBVTtZQUM1RGlDLFFBQVE7UUFDVjtJQUNGO0lBRUEsTUFBTTJDLGNBQWM7UUFDbEIsT0FBTyxJQUFJLENBQUN4RSxPQUFPLENBQUM7SUFDdEI7SUFoTkF5RSxhQUFjO1FBQ1osSUFBSSxDQUFDN0QsT0FBTyxHQUFHcEI7SUFDakI7QUErTUY7QUFFQSw0QkFBNEI7QUFDNUIsTUFBTWtGLGNBQWMsSUFBSWhGO0FBQ3hCLGlFQUFlZ0YsV0FBV0EsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFx1c2VyXFxEZXNrdG9wXFxlbWVyZ2VudFxcZnJvbnRlbmRcXHNyY1xcbGliXFxhcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUE1GdXNpb24gVGhyZWUtUGhhc2UgV29ya2Zsb3cgQVBJIENsaWVudFxyXG5cclxuLy8gVVJMIHZhbGlkYXRpb24gZnVuY3Rpb25cclxuY29uc3QgdmFsaWRhdGVBcGlVcmwgPSAodXJsKSA9PiB7XHJcbiAgaWYgKCF1cmwgfHwgdHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKTtcclxuICAgIC8vIENoZWNrIGlmIGl0J3MgSFRUUCBvciBIVFRQUyBwcm90b2NvbFxyXG4gICAgcmV0dXJuIHVybE9iai5wcm90b2NvbCA9PT0gJ2h0dHA6JyB8fCB1cmxPYmoucHJvdG9jb2wgPT09ICdodHRwczonO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gR2V0IGFuZCB2YWxpZGF0ZSBBUEkgYmFzZSBVUkxcclxuY29uc3QgZ2V0VmFsaWRhdGVkQXBpVXJsID0gKCkgPT4ge1xyXG4gIGNvbnN0IGVudlVybCA9IHByb2Nlc3MuZW52LlJFQUNUX0FQUF9CQUNLRU5EX1VSTDtcclxuICAvLyBEZWZhdWx0IHRvIHRoZSB2MSBBUEkgcnVubmluZyBsb2NhbGx5XHJcbiAgY29uc3QgZGVmYXVsdFVybCA9ICdodHRwOi8vbG9jYWxob3N0OjgwMDAvYXBpJztcclxuICBcclxuICAvLyBGaXJzdCwgdHJ5IHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZVxyXG4gIGlmIChlbnZVcmwgJiYgdmFsaWRhdGVBcGlVcmwoZW52VXJsKSkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBBUEkgVVJMIGZyb20gZW52aXJvbm1lbnQ6JywgZW52VXJsKTtcclxuICAgICAgfVxyXG4gICAgcmV0dXJuIGVudlVybDtcclxuICB9XHJcbiAgXHJcbiAgLy8gSWYgZW52aXJvbm1lbnQgVVJMIGlzIGludmFsaWQsIGxvZyB3YXJuaW5nIGFuZCBjaGVjayBkZWZhdWx0XHJcbiAgaWYgKGVudlVybCAmJiAhdmFsaWRhdGVBcGlVcmwoZW52VXJsKSkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBBUEkgVVJMIGluIGVudmlyb25tZW50IHZhcmlhYmxlIFJFQUNUX0FQUF9CQUNLRU5EX1VSTDonLCBlbnZVcmwpO1xyXG4gICAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIFZhbGlkYXRlIHRoZSBkZWZhdWx0IFVSTFxyXG4gIGlmICh2YWxpZGF0ZUFwaVVybChkZWZhdWx0VXJsKSkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBkZWZhdWx0IEFQSSBVUkw6JywgZGVmYXVsdFVybCk7XHJcbiAgICAgIH1cclxuICAgIHJldHVybiBkZWZhdWx0VXJsO1xyXG4gIH1cclxuICBcclxuICAvLyBJZiBldmVuIHRoZSBkZWZhdWx0IGlzIGludmFsaWQgKHNob3VsZCBuZXZlciBoYXBwZW4pLCB0aHJvdyBlcnJvclxyXG4gIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgQVBJIFVSTCBhdmFpbGFibGUuIFBsZWFzZSBjaGVjayBSRUFDVF9BUFBfQkFDS0VORF9VUkwgZW52aXJvbm1lbnQgdmFyaWFibGUuJyk7XHJcbn07XHJcblxyXG5jb25zdCBBUElfQkFTRV9VUkwgPSBnZXRWYWxpZGF0ZWRBcGlVcmwoKTtcclxuY29uc3QgQVBJX1RJTUVPVVRfTVMgPSAxMDAwMDsgLy8gMTAgc2Vjb25kIHRpbWVvdXRcclxuXHJcbmNsYXNzIFBNRnVzaW9uQVBJIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuYmFzZVVSTCA9IEFQSV9CQVNFX1VSTDtcclxuICB9XHJcblxyXG4gIC8vIEhlbHBlciBtZXRob2QgdG8gZ2V0IGF1dGggaGVhZGVyc1xyXG4gIGFzeW5jIGdldEF1dGhIZWFkZXJzKCkge1xyXG4gICAgY29uc3QgdXNlcklkID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlcklkJykgOiBudWxsO1xyXG4gICAgLy8gVXNlIGRlbW8gdXNlciBhcyBmYWxsYmFjayBpZiBubyB1c2VyIGlzIGxvZ2dlZCBpblxyXG4gICAgY29uc3QgZGVtb1VzZXJJZCA9ICdhYTgzMjE0Yy0zNjdiLTQyMzEtYTY4Mi0wYmNjNDQxN2Q5NTQnO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAnWC1Vc2VyLUlEJzogdXNlcklkIHx8IGRlbW9Vc2VySWRcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBHZW5lcmljIEFQSSByZXF1ZXN0IG1ldGhvZCB3aXRoIHRpbWVvdXRcclxuICBhc3luYyByZXF1ZXN0KGVuZHBvaW50LCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCB0aGlzLmdldEF1dGhIZWFkZXJzKCk7XHJcbiAgICBcclxuICAgIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgICAgaGVhZGVycyxcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgIH07XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQ3JlYXRlIGFuIEFib3J0Q29udHJvbGxlciB0byBoYW5kbGUgdGltZW91dHNcclxuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIEFQSV9USU1FT1VUX01TKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfSR7ZW5kcG9pbnR9YCwge1xyXG4gICAgICAgIC4uLmNvbmZpZyxcclxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVvdXQgc2luY2UgdGhlIHJlcXVlc3QgY29tcGxldGVkXHJcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gLSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGAgLSAke2Vycm9yRGF0YS5tZXNzYWdlIHx8IGVycm9yRGF0YS5lcnJvciB8fCBKU09OLnN0cmluZ2lmeShlcnJvckRhdGEpfWA7XHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYCAtICR7ZXJyb3JUZXh0fWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7ICAgICAgXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgcmVxdWVzdCB0aW1lb3V0IGFmdGVyICR7QVBJX1RJTUVPVVRfTVN9bXNgKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zb2xlLmVycm9yKGBBUEkgRXJyb3IgZm9yICR7ZW5kcG9pbnR9OmAsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gUEhBU0UgMTogUFJPSkVDVCBDUkVBVElPTiBFTkRQT0lOVFNcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gIGFzeW5jIGNyZWF0ZVByb2plY3QocHJvamVjdERhdGEpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJy9wcm9qZWN0cycsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHByb2plY3REYXRhKSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0UHJvamVjdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCcvcHJvamVjdHMnKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFByb2plY3QocHJvamVjdElkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvcHJvamVjdHMvJHtwcm9qZWN0SWR9YCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyB1cGRhdGVQcm9qZWN0KHByb2plY3RJZCwgcHJvamVjdERhdGEpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9wcm9qZWN0cy8ke3Byb2plY3RJZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHByb2plY3REYXRhKSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2VuZXJhdGVQcm9qZWN0V0JTKHByb2plY3RJZCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL3Byb2plY3RzLyR7cHJvamVjdElkfS93YnNgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRQcm9qZWN0V0JTKHByb2plY3RJZCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL3Byb2plY3RzLyR7cHJvamVjdElkfS93YnNgKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHN5bmNUYXNrc0Zyb21XQlMocHJvamVjdElkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvcHJvamVjdHMvJHtwcm9qZWN0SWR9L3dicy9zeW5jLXRhc2tzYCwge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0VGFza3MocHJvamVjdElkID0gbnVsbCkge1xyXG4gICAgY29uc3QgZW5kcG9pbnQgPSBwcm9qZWN0SWQgPyBgL3Rhc2tzP3Byb2plY3RfaWQ9JHtwcm9qZWN0SWR9YCA6ICcvdGFza3MnO1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChlbmRwb2ludCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBhc3NpZ25UYXNrKHRhc2tJZCwgYXNzaWduZWRUbykge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL3Rhc2tzLyR7dGFza0lkfS9hc3NpZ25gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgYXNzaWduZWRfdG86IGFzc2lnbmVkVG8gfSksXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldERpc2NpcGxpbmVVc2VycyhkaXNjaXBsaW5lKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvZGlzY2lwbGluZXMvJHtkaXNjaXBsaW5lfS91c2Vyc2ApO1xyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIFBIQVNFIDI6IFRFQU1TIEVYRUNVVElPTiBFTkRQT0lOVFNcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gIGFzeW5jIGdldERpc2NpcGxpbmVLYW5iYW4oZGlzY2lwbGluZUlkLCBwcm9qZWN0SWQpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9kaXNjaXBsaW5lcy8ke2Rpc2NpcGxpbmVJZH0va2FuYmFuP3Byb2plY3RfaWQ9JHtwcm9qZWN0SWR9YCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyB1cGRhdGVUYXNrKHRhc2tJZCwgdGFza0RhdGEpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC90YXNrcy8ke3Rhc2tJZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRhc2tEYXRhKSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgYXNzaWduVGFzayh0YXNrSWQsIGFzc2lnbmVlSWQpIHtcclxuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRhc2sodGFza0lkLCB7IGFzc2lnbmVlX2lkOiBhc3NpZ25lZUlkIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdXBkYXRlVGFza1N0YXR1cyh0YXNrSWQsIHN0YXR1cykge1xyXG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVGFzayh0YXNrSWQsIHsgc3RhdHVzIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gUEhBU0UgMzogRE9DVU1FTlQgQ09OVFJPTCBFTkRQT0lOVFNcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgYXN5bmMgZ2V0RG9jdW1lbnRzKHBhcmFtcyA9IHt9KSB7XHJcbiAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcclxuICAgIGlmIChwYXJhbXMuc3RhdHVzKSBxdWVyeS5hcHBlbmQoJ3N0YXR1cycsIHBhcmFtcy5zdGF0dXMpO1xyXG4gICAgaWYgKHBhcmFtcy5yZXZpZXdfc3RlcCkgcXVlcnkuYXBwZW5kKCdyZXZpZXdfc3RlcCcsIHBhcmFtcy5yZXZpZXdfc3RlcCk7XHJcbiAgICBpZiAocGFyYW1zLnByb2plY3RfaWQpIHF1ZXJ5LmFwcGVuZCgncHJvamVjdF9pZCcsIHBhcmFtcy5wcm9qZWN0X2lkKTtcclxuICAgIGNvbnN0IHFzID0gcXVlcnkudG9TdHJpbmcoKTtcclxuICAgIGNvbnN0IGVuZHBvaW50ID0gcXMgPyBgL2RvY3VtZW50cz8ke3FzfWAgOiAnL2RvY3VtZW50cyc7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGVuZHBvaW50KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldERjY0RvY3VtZW50cygpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJy9kb2N1bWVudHMvZGNjJyk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBmaW5hbGl6ZURvY3VtZW50KGRvY3VtZW50SWQpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9kY2NfZmluYWxpemVgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHVwZGF0ZURvY3VtZW50U3RhdHVzKGRvY3VtZW50SWQsIHN0YXR1c0RhdGEpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9zdGF0dXNgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHN0YXR1c0RhdGEpXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldERvY3VtZW50QW5hbHl0aWNzKHByb2plY3RJZCkge1xyXG4gICAgY29uc3QgZW5kcG9pbnQgPSBwcm9qZWN0SWRcclxuICAgICAgPyBgL2RvY3VtZW50cy9hbmFseXRpY3Mvc3VtbWFyeT9wcm9qZWN0X2lkPSR7cHJvamVjdElkfWBcclxuICAgICAgOiAnL2RvY3VtZW50cy9hbmFseXRpY3Mvc3VtbWFyeSc7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGVuZHBvaW50KTtcclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyBHRU5FUkFMIEVORFBPSU5UU1xyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgYXN5bmMgZ2V0RGlzY2lwbGluZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCcvZGlzY2lwbGluZXMnKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGNyZWF0ZURpc2NpcGxpbmUoZGlzY2lwbGluZURhdGEpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJy9kaXNjaXBsaW5lcycsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRpc2NpcGxpbmVEYXRhKSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgYWRkRGlzY2lwbGluZU1lbWJlcihuYW1lLCB1c2VySWQpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9kaXNjaXBsaW5lcy8ke25hbWV9L21lbWJlcnMvJHt1c2VySWR9YCwge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJ1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyByZW1vdmVEaXNjaXBsaW5lTWVtYmVyKG5hbWUsIHVzZXJJZCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2Rpc2NpcGxpbmVzLyR7bmFtZX0vbWVtYmVycy8ke3VzZXJJZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ0RFTEVURSdcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgaGVhbHRoQ2hlY2soKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCcvaGVhbHRoJyk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBDcmVhdGUgc2luZ2xldG9uIGluc3RhbmNlXHJcbmNvbnN0IHBtZnVzaW9uQVBJID0gbmV3IFBNRnVzaW9uQVBJKCk7XHJcbmV4cG9ydCBkZWZhdWx0IHBtZnVzaW9uQVBJOyAiXSwibmFtZXMiOlsidmFsaWRhdGVBcGlVcmwiLCJ1cmwiLCJ1cmxPYmoiLCJVUkwiLCJwcm90b2NvbCIsImVycm9yIiwiZ2V0VmFsaWRhdGVkQXBpVXJsIiwiZW52VXJsIiwicHJvY2VzcyIsImVudiIsIlJFQUNUX0FQUF9CQUNLRU5EX1VSTCIsImRlZmF1bHRVcmwiLCJjb25zb2xlIiwibG9nIiwid2FybiIsIkVycm9yIiwiQVBJX0JBU0VfVVJMIiwiQVBJX1RJTUVPVVRfTVMiLCJQTUZ1c2lvbkFQSSIsImdldEF1dGhIZWFkZXJzIiwidXNlcklkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImRlbW9Vc2VySWQiLCJyZXF1ZXN0IiwiZW5kcG9pbnQiLCJvcHRpb25zIiwiaGVhZGVycyIsImNvbmZpZyIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJyZXNwb25zZSIsImZldGNoIiwiYmFzZVVSTCIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsIm9rIiwiZXJyb3JNZXNzYWdlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImVycm9yRGF0YSIsImpzb24iLCJtZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yVGV4dCIsInRleHQiLCJuYW1lIiwiY3JlYXRlUHJvamVjdCIsInByb2plY3REYXRhIiwibWV0aG9kIiwiYm9keSIsImdldFByb2plY3RzIiwiZ2V0UHJvamVjdCIsInByb2plY3RJZCIsInVwZGF0ZVByb2plY3QiLCJnZW5lcmF0ZVByb2plY3RXQlMiLCJnZXRQcm9qZWN0V0JTIiwic3luY1Rhc2tzRnJvbVdCUyIsImdldFRhc2tzIiwiYXNzaWduVGFzayIsInRhc2tJZCIsImFzc2lnbmVkVG8iLCJhc3NpZ25lZF90byIsImdldERpc2NpcGxpbmVVc2VycyIsImRpc2NpcGxpbmUiLCJnZXREaXNjaXBsaW5lS2FuYmFuIiwiZGlzY2lwbGluZUlkIiwidXBkYXRlVGFzayIsInRhc2tEYXRhIiwiYXNzaWduZWVJZCIsImFzc2lnbmVlX2lkIiwidXBkYXRlVGFza1N0YXR1cyIsImdldERvY3VtZW50cyIsInBhcmFtcyIsInF1ZXJ5IiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwicmV2aWV3X3N0ZXAiLCJwcm9qZWN0X2lkIiwicXMiLCJ0b1N0cmluZyIsImdldERjY0RvY3VtZW50cyIsImZpbmFsaXplRG9jdW1lbnQiLCJkb2N1bWVudElkIiwidXBkYXRlRG9jdW1lbnRTdGF0dXMiLCJzdGF0dXNEYXRhIiwiZ2V0RG9jdW1lbnRBbmFseXRpY3MiLCJnZXREaXNjaXBsaW5lcyIsImNyZWF0ZURpc2NpcGxpbmUiLCJkaXNjaXBsaW5lRGF0YSIsImFkZERpc2NpcGxpbmVNZW1iZXIiLCJyZW1vdmVEaXNjaXBsaW5lTWVtYmVyIiwiaGVhbHRoQ2hlY2siLCJjb25zdHJ1Y3RvciIsInBtZnVzaW9uQVBJIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/lib/api.js\n"));

/***/ })

});